---
title: 'Chi Square c-sections by state!'
author: "Adam Dede"
date: "2024-06-22"
output:
  html_document:
    toc: yes
    toc_float: yes
editor_options:
  chunk_output_type: console
---


## set environment

```{r message = FALSE, warning = FALSE}

# Set rendering parameters
knitr::opts_chunk$set(message = FALSE, warning = FALSE)


install.packages("devtools")

library(devtools)

# Install gmailr from GitHub
install.packages("gmailr", repos = "https://cloud.r-project.org/")


# Load gmailr package
library(gmailr)


library(tidyverse)


```

## authenticate

```{r authenticate}


# Path to your credentials.json file
credentials_path <- "C:/Users/Adam/Downloads/client_secret_322202062153-13rch4dos51h1gp92chhdf2bsq4t3j1i.apps.googleusercontent.com.json"

# Configure the OAuth 2.0 client ID and secret
gm_auth_configure(path = credentials_path)

# Authenticate and authorize access to your Gmail account
gm_auth()


```
## how to plot a US map
```{r plotting a US map}
get_email_timestamps <- function(query = "in:inbox", max_results = 2000) {
  # List messages based on query
  messages <- gm_messages(search = query, num_results = max_results)
  outmessages = data.frame()
  for (page in 1:length(messages)) {
    print(page)
    messages[[page]]$messages -> test
    as.data.frame(test) -> test
    test[,grepl("id", names(test))] -> test
    pivot_longer(test,
                 cols = c(1:dim(test)[2]), 
                 values_to = "IDs",
                 names_to = "ord") -> test
    outmessages = rbind(outmessages, test)
  }
  # Initialize a list to store timestamps
  timestamps <- list()
  
  # Loop through each message and extract the internal date
  counter = 1
  for (msg_id in outmessages$IDs) {
    if(counter %% 100 == 0){
      print(counter)
    }
    msg <- gm_message(msg_id)
    internal_date <- msg$internalDate
    timestamp <- floor(as.numeric(internal_date) / 1000 / 60 / 60)
    timestamps <- append(timestamps, list(timestamp))
    counter = 1+counter
  }
  
  # Convert list to a data frame
  timestamps_df <- data.frame(Timestamp = unlist(timestamps))
  
  return(timestamps_df)
}

# Extract timestamps for the last 100 emails in the inbox
timestamps_df <- get_email_timestamps(max_results = 10000)

```
## get number of emails in each hour of the sample
```{r email per hour data}

timestamps_df %>% group_by(Timestamp) %>%
  summarize(count = n()) -> test



```
## combining data with actual counts

```{r get birth counts}

#here are the total births for each state
#data downloaded from: https://wonder.cdc.gov/
data <- read_delim(paste0(path, 'Natality, 2016-2022 expanded.txt'), 
                   delim = "\t", # Specify tab as the delimiter
                   quote = "\"", # Specify quotation marks as text qualifiers
                   col_names = c("Notes", "StateOfRes", "StateCode", "Births"),
                   skip = 1 # Adjust this as needed to skip any header info
)
data <- data[!is.na(data$StateCode), ]
data <- select(data, -Notes) # Remove the 'Notes' column

data$StateOfRes <- tolower(data$StateOfRes)

names(data) <- c("stateLong", "code", "Births")
cSec <- merge(cSec, data) %>% select(c('YEAR', 'stateLong', 'RATE', 'Births'))


```
## make a new plot showing total births!

```{r total birth plot}

merge(state, cSec) -> plotDat
plotDat <- plotDat %>% arrange(order)

ggplot(data = plotDat, aes(x = long, y = lat, fill = Births, group = group))+
  geom_polygon(color = 'white')  + 
  theme(axis.title.x=element_blank(), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()) + 
  ggtitle('U.S. births map') + 
  coord_fixed(1.3)




```

## do a chi-square test to assess if c-sections vary over states

```{r chi squared test}

cSec$cSec = round(cSec$Births * (cSec$RATE/100))
cSec$vaginal = cSec$Births - cSec$cSec

chisq.test(cSec[,c('cSec', 'vaginal')])




```
## make a plot of deviation from the expectation of independence

```{r deviation plot}
cSec$expectedC =  round(cSec$Births * mean((cSec$RATE/100)))
cSec$deviation = (cSec$cSec - cSec$expectedC) / cSec$expectedC

merge(state, cSec) -> plotDat
plotDat <- plotDat %>% arrange(order)

ggplot(data = plotDat, aes(x = long, y = lat, fill = deviation, group = group))+
  geom_polygon(color = 'white')  + 
  scale_fill_gradientn(
    colors = c('navy',  "green", "red")) +
  theme(axis.title.x=element_blank(), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(), 
        axis.text.y=element_blank(), 
        axis.ticks.y=element_blank()) + 
  ggtitle('U.S. c-section deviation') + 
  coord_fixed(1.3) 



```
